import Mathlib
import ShearerTriangleFreeInd.Analysis
import ShearerTriangleFreeInd.Analysis_W

namespace SimpleGraph

open Finset SimpleGraph BigOperators
open Classical

variable {V : Type} {G : SimpleGraph V} {v : V}
variable [Fintype V]


def VertexFinset (G : SimpleGraph V) : Finset V := univ
noncomputable def averageDegree (G : SimpleGraph V) := ùîº v, (G.degree v : ‚Ñö)
noncomputable def indepSetFinsetAll (G : SimpleGraph V) : Finset (Set V) := {s | G.IsIndepSet s}

scoped notation "V(" G ")" => VertexFinset G
scoped notation "E(" G ")" => edgeFinset G
scoped notation "d(" G ")" => averageDegree G
scoped notation "Œ±(" G ")" => indepNum G
scoped notation "‚Ñê(" G ")" => indepSetFinsetAll G

lemma VG_rw : V(G) = univ := rfl
lemma VG_Fintype : #V(G) = Fintype.card V := rfl

lemma d_rw : d(G) = ùîº v, (G.degree v : ‚Ñö) := rfl

lemma I_rw {S : Set V} : S ‚àà ‚Ñê(G) ‚Üî G.IsIndepSet S := by
  simp only [indepSetFinsetAll, mem_filter, mem_univ, true_and]


/-
  ## Lemmas about averageDegree
-/

lemma averageDegree_nonneg : 0 ‚â§ d(G) :=
  expect_nonneg (fun _ _ ‚Ü¶ Nat.cast_nonneg' _)

lemma averageDegree_pos_from_nonzero (hd : d(G) ‚â† 0) : 0 < d(G) :=
  lt_of_le_of_ne averageDegree_nonneg hd.symm

lemma averageDegree_eq_twice_card_edges_div_card : #V(G) * d(G) = 2 * #E(G) := by
  convert congrArg (Nat.cast (R := ‚Ñö)) (sum_degrees_eq_twice_card_edges G) using 1
  ¬∑ by_cases hV : Nonempty V
    ¬∑ rw [d_rw, Fintype.expect_eq_sum_div_card, VG_Fintype, (Nat.cast_sum univ _)]
      exact mul_div_cancel‚ÇÄ _ (by simp)
    ¬∑ simp_all [VG_rw]
  ¬∑ rw [Nat.cast_mul, Nat.cast_ofNat]

lemma edgeFinset_empty_from_averageDegree_zero (hd : d(G) = 0) : E(G) = ‚àÖ := by
  rw [‚Üêcard_eq_zero, ‚ÜêRat.natCast_eq_zero, ‚Üêmul_eq_zero_iff_left (a := 2) (by norm_num),
      ‚ÜêaverageDegree_eq_twice_card_edges_div_card, hd, mul_zero]



lemma averageDegree_zero_from_vertexType_empty (hV : IsEmpty V) : d(G) = 0 := by
  simp only [averageDegree, univ_eq_empty, expect_empty]

lemma vertexType_Nonempty_from_averageDegree_pos (h : 0 < d(G)) : Nonempty V  := by
  by_contra hV
  rw [not_nonempty_iff] at hV
  linarith [averageDegree_zero_from_vertexType_empty (G := G) hV]


lemma edgeFinset_empty_iff_averageDegree_zero : E(G) = ‚àÖ ‚Üî d(G) = 0 := by
  constructor
  ¬∑ intro hE
    have this : #V(G) * d(G) = 0 := by
      simp [averageDegree_eq_twice_card_edges_div_card, card_eq_zero.mpr hE]
    rcases mul_eq_zero.1 this with (h | h)
    ¬∑ refine averageDegree_zero_from_vertexType_empty (Fintype.card_eq_zero_iff.mp ?_ )
      exact_mod_cast h
    ¬∑ exact h
  ¬∑ exact edgeFinset_empty_from_averageDegree_zero


lemma averageDegree_real_cast : (d(G) : ‚Ñù) = ùîº v, (G.degree v : ‚Ñù) :=
    algebraMap.coe_expect (M := ‚Ñö) _ _

/-
  ## Closed neighborhood of vertex
-/

omit [Fintype V] in
variable (G) (v) in
def closedNeighborSet := insert v (G.neighborSet v)

omit [Fintype V] in
lemma self_mem_closedNeighborSet : v ‚àà G.closedNeighborSet v :=
  Set.mem_insert v (G.neighborSet v)

omit [Fintype V] in
lemma nonempty_closedNeighborSet : (G.closedNeighborSet v).Nonempty :=
    ‚ü®_, self_mem_closedNeighborSet‚ü©

omit [Fintype V] in
lemma Adj_of_mem_closedNeighborSet_of_ne_v {u v : V} (hne : v ‚â† u)
    (hu : u ‚àà G.closedNeighborSet v)
     : G.Adj v u := by
  rcases (Set.mem_insert_iff.1 hu) with (hu | hu)
  ¬∑ exact (hne hu.symm).elim
  ¬∑ exact hu

/-
  ## Lemmas induced graph vertex counts
-/

lemma induce_vertex_card (S : Set V) [DecidablePred (¬∑ ‚àà S)]
    : #V(G.induce S) = #S.toFinset := by simp [VG_rw]

lemma vertex_card_induce_sum (S : Set V) : #V(G) = #S.toFinset + #S·∂ú.toFinset := by
  convert (filter_card_add_filter_neg_card_eq_card (¬∑ ‚àà S)).symm <;>
    (ext _; simp [VG_rw])

lemma induce_vertex_card_compl_lt {S : Set V} (hS : S.Nonempty) : #V(G.induce S·∂ú) < #V(G) := by
  rw [induce_vertex_card, VG_rw]
  refine card_lt_card ‚ü®fun _ _ ‚Ü¶ mem_univ _, sdiff_nonempty.mp ?_‚ü©
  convert Set.Aesop.toFinset_nonempty_of_nonempty hS
  rw [Set.toFinset_compl, sdiff_compl, inf_of_le_right (le_iff_subset.2 (subset_univ _))]

lemma card_vertices_eq_zero_from_empty (hV : IsEmpty V) : #V(G) = 0 :=
  card_eq_zero.2 (univ_eq_empty_iff.2 hV)

lemma vertex_singelton_card (v : V) : #(V(G.induce {v})) = 1 := by
  convert induce_vertex_card {v}
  rw [Set.toFinset_singleton, card_singleton]

lemma closedNeighbor_card (v : V) : #(G.closedNeighborSet v).toFinset = G.degree v + 1 := by
  simp [closedNeighborSet, ‚ÜêneighborFinset_eq_filter]

lemma expect_closedNeighbor_card_real (hV : Nonempty V)
    : ùîº v, (#(G.closedNeighborSet v).toFinset : ‚Ñù) = d(G) + 1 := by
  simp_rw [closedNeighbor_card, Nat.cast_add, expect_add_distrib, averageDegree_real_cast,
      Nat.cast_one, expect_const univ_nonempty]

lemma closedNeighbor_induce_card (v : V)
    : #(V(G.induce (G.closedNeighborSet v))) = G.degree v + 1 := by
  rw [‚ÜêclosedNeighbor_card, induce_vertex_card]


/-
  ## Lemmas induced graph edge counts
-/

variable (G) in
noncomputable def EdgeFinsetInducedBy (S : Set V) := filter (fun e ‚Ü¶ ‚àÄ v ‚àà e, v ‚àà S) E(G)

variable (G) in
noncomputable def EdgeIncidenceFinset (S : Set V) := filter (‚àÉ v ‚àà S, v ‚àà ¬∑) E(G)


lemma induceEdgeMap (S : Set V) :
    map (Function.Embedding.subtype _).sym2Map E(G.induce S)
    = G.EdgeFinsetInducedBy S := by
  ext e
  constructor <;> simp_rw [EdgeFinsetInducedBy, mem_map, mem_filter, mem_edgeFinset]
  ¬∑ intro ‚ü®e', ‚ü®he', hee'‚ü©‚ü©; subst hee'
    refine ‚ü®(Embedding.map_mem_edgeSet_iff (Embedding.induce _)).2 he', ?_‚ü©
    simp only [Function.Embedding.sym2Map_apply, Function.Embedding.subtype_apply,
      Sym2.mem_map, Subtype.exists, exists_and_right, exists_eq_right]
    exact fun _ ‚ü®h, _‚ü© ‚Ü¶ h
  ¬∑ simp only [Function.Embedding.sym2Map_apply, Function.Embedding.subtype_apply, and_imp]
    intro he hev
    have ‚ü®v, w, hvwe‚ü©  := (Sym2.exists).1 ‚ü®e, rfl‚ü©; subst hvwe
    refine ‚ü®s(‚ü®v, hev _ (Sym2.mem_mk_left _ _)‚ü©, ‚ü®w, hev _ (Sym2.mem_mk_right _ _)‚ü©), he, by simp‚ü©

lemma induce_edge_card (S : Set V) :
    #E(G.induce S) = #(G.EdgeFinsetInducedBy S) := by rw [‚ÜêinduceEdgeMap, card_map]

lemma EdgeIncidenceFinset_card_zero_from_averageDegree_zero
    (hd : d(G) = 0) (S : Set V) : #(G.EdgeIncidenceFinset S) = 0 := by
  simp [EdgeIncidenceFinset, edgeFinset_empty_from_averageDegree_zero hd]

lemma induceAveragedegree_zero_from_averageDegree_zero
    (hd : d(G) = 0) (S : Set V) : d(G.induce S) = 0 := by
  rw [‚ÜêedgeFinset_empty_iff_averageDegree_zero, ‚Üêcard_eq_zero] at *
  rw [‚ÜêNat.le_zero, ‚Üêhd, induce_edge_card]
  exact card_le_card (filter_subset _ _)

lemma edge_card_induce_sum (S : Set V) :
    #E(G) = #(G.EdgeIncidenceFinset S) + #E(induce S·∂ú G) := by
  convert (filter_card_add_filter_neg_card_eq_card (‚àÉ v ‚àà S, v ‚àà ¬∑) (s := E(G))).symm
  convert (induce_edge_card S·∂ú)
  ext _
  simp_rw [EdgeFinsetInducedBy, not_exists, not_and, Set.mem_compl_iff]
  congr! 3
  constructor <;> exact fun hx _ hv hvS ‚Ü¶ hx _ hvS hv

lemma edge_incidence_singelton_eq (v : V) : G.EdgeIncidenceFinset {v} = G.incidenceFinset v := by
  ext _
  simp [mem_incidenceFinset, EdgeIncidenceFinset, mem_filter, incidenceSet]

lemma edge_incidence_singelton_card (v : V) : #(G.EdgeIncidenceFinset {v}) = G.degree v := by
  rw [edge_incidence_singelton_eq, card_incidenceFinset_eq_degree]

lemma degree_zero_of_avg_zero (hd : d(G) = 0) : G.degree v = 0 := by
  rw [‚Üêedge_incidence_singelton_card]
  exact EdgeIncidenceFinset_card_zero_from_averageDegree_zero hd _

lemma incident_closedNeighbor_mem_iff (e : Sym2 V) (v : V) :
    (e ‚àà G.EdgeIncidenceFinset (G.closedNeighborSet v)) ‚Üî
    ‚àÉ w ‚àà G.neighborSet v, e ‚àà G.incidenceSet w := by
  simp_rw [EdgeIncidenceFinset, mem_filter, closedNeighborSet, Set.mem_insert_iff,
      mem_neighborSet, Set.mem_toFinset, exists_eq_or_imp, incidenceSet, Set.mem_setOf_eq]
  constructor
  ¬∑ rintro ‚ü®he, (hve | ‚ü®w, hwv, hwe‚ü©)‚ü©
    ¬∑ exact ‚ü®Sym2.Mem.other hve, ‚ü®by rwa [‚Üêmem_edgeSet, Sym2.other_spec], ‚ü®he, Sym2.other_mem _‚ü©‚ü©‚ü©
    ¬∑ exact ‚ü®w, ‚ü®hwv, ‚ü®he, hwe‚ü©‚ü©‚ü©
  ¬∑ exact fun ‚ü®w, ‚ü®hAdj, ‚ü®he, hwe‚ü©‚ü©‚ü© ‚Ü¶ ‚ü®he, Or.inr ‚ü®w, ‚ü®hAdj, hwe‚ü©‚ü©‚ü©

lemma incident_closedNeighbor_iff (v : V) :
    G.EdgeIncidenceFinset (G.closedNeighborSet v) =
    Finset.biUnion (G.neighborFinset v) (fun u ‚Ü¶ (G.incidenceFinset u)):= by
  ext _
  simp [incident_closedNeighbor_mem_iff]

omit [Fintype V] in
lemma triangle_free_neighbors_pairwise_disjoint_incidenceSet (v : V) (hT : G.CliqueFree 3) :
    (G.neighborSet v).PairwiseDisjoint (fun u ‚Ü¶ G.incidenceSet u) := by
  rw [Set.pairwiseDisjoint_iff]
  intro u hu w hw ‚ü®e, ‚ü®heu, hew‚ü©‚ü©
  by_contra huw
  exact isIndepSet_neighborSet_of_triangleFree _ hT _ hu hw huw
    (adj_of_mem_incidenceSet _ huw heu hew)

lemma triangle_free_neighbors_pairwise_disjoint_incidenceFinset (v : V) (hT : G.CliqueFree 3) :
    (G.neighborSet v).PairwiseDisjoint (fun u ‚Ü¶ G.incidenceFinset u) := by
  have this := triangle_free_neighbors_pairwise_disjoint_incidenceSet (v := v) hT
  rw [Set.pairwiseDisjoint_iff, pairwiseDisjoint_iff] at *
  exact fun u hu w hw ‚ü®e, he‚ü© ‚Ü¶
    (this hu hw ‚ü®e, by rwa [mem_inter, mem_incidenceFinset, mem_incidenceFinset] at he‚ü©)

lemma incident_closedNeighbor_card (hT : G.CliqueFree 3) (v : V) :
    #(G.EdgeIncidenceFinset (G.closedNeighborSet v)) =
    ‚àë u ‚àà G.neighborFinset v, G.degree u := by
  rw [incident_closedNeighbor_iff, card_biUnion ?_]
  ¬∑ simp only [card_incidenceFinset_eq_degree]
  ¬∑ convert (triangle_free_neighbors_pairwise_disjoint_incidenceFinset v hT)
    ext _; simp

lemma incidence_closedNeighbor_expectation (hT : G.CliqueFree 3)
    : ùîº v, (#(G.EdgeIncidenceFinset (G.closedNeighborSet v)) : ‚Ñö) = ùîº v, (G.degree v : ‚Ñö)^2 := by
  conv => lhs; rhs; intro _; rw [incident_closedNeighbor_card hT, Nat.cast_sum,
    ‚Üê(Fintype.sum_ite_mem _ _)]
  simp_rw [expect_sum_comm]
  conv => lhs; rhs; intro _; rhs; intro i; rw [‚Üêmul_boole]
  conv => lhs; rhs; intro _; rw [‚Üêmul_expect, expect, sum_boole, mul_smul_comm]
  rw [expect, smul_sum]
  congr; ext _; rw [pow_two]; congr 4
  ext _; simp only [mem_neighborFinset, adj_comm, mem_filter, mem_univ, true_and]

lemma incidence_closedNeighbor_expectation_real (hT : G.CliqueFree 3)
    : ùîº v, (#(G.EdgeIncidenceFinset (G.closedNeighborSet v)) : ‚Ñù) = ùîº v, (G.degree v : ‚Ñö)^2 := by
  rw [‚Üêincidence_closedNeighbor_expectation hT]
  convert (algebraMap.coe_expect (M := ‚Ñö) (N := ‚Ñù) _ _).symm


lemma averageDegree_square_bound : d(G) ^ 2 ‚â§ ùîº v, (G.degree v : ‚Ñö)^2 := by
  convert expect_mul_sq_le_sq_mul_sq (f := fun v ‚Ü¶ (G.degree v : ‚Ñö)) (g := fun _ ‚Ü¶ 1) univ
  ¬∑ simp only [averageDegree, mul_one]
  ¬∑ by_cases h_nonempty : Nonempty V
    ¬∑ rw [expect_const (univ_nonempty_iff.2 h_nonempty), one_pow, mul_one]
    ¬∑ simp_all




/-
  ## Recursions for Œ± and i
-/


lemma bot_Is_independent : ‚ä• ‚àà ‚Ñê(G) := by
  rw [I_rw]
  exact fun _ hx _ _ _ _ ‚Ü¶ hx

lemma indepSetFinsetAll_nonempty : ‚Ñê(G).Nonempty :=
  ‚ü®‚ä•, bot_Is_independent‚ü©

lemma indepSetFinsetAll_subset {S‚ÇÅ S‚ÇÇ : Set V} (hind : S‚ÇÅ ‚àà ‚Ñê(G)) (hsub : S‚ÇÇ ‚äÜ S‚ÇÅ)
    : S‚ÇÇ ‚àà ‚Ñê(G) := by
  rw [I_rw] at *
  exact fun  x hx y hy hxy ‚Ü¶ hind (hsub hx) (hsub hy) hxy

lemma IsIndependentInduce (S : Set V) (I : Set S) :
    I ‚àà ‚Ñê(G.induce S) ‚Üî (Subtype.val '' I) ‚àà ‚Ñê(G) := by
  simp_rw [I_rw, IsIndepSet, comap_adj, Function.Embedding.subtype_apply]
  constructor
  ¬∑ intro h _ hx _ hy hxy
    rw [Subtype.coe_image] at hx hy
    exact h hx.2 hy.2 (Subtype.coe_ne_coe.mp hxy)
  ¬∑ intro h _ hx _ hy hxy
    exact h (Set.mem_image_of_mem _ hx) (Set.mem_image_of_mem _ hy) (Subtype.coe_ne_coe.mpr hxy)

lemma IsIndependentInduce' {S I : Set V} (hIS : I ‚äÜ S) :
    {x | x.1 ‚àà I} ‚àà ‚Ñê(G.induce S) ‚Üî I ‚àà ‚Ñê(G):= by
  rw [IsIndependentInduce, Subtype.coe_image_of_subset hIS]

def embeddingOfSubsetSubtype (S : Set V) [DecidablePred (¬∑ ‚àà S)] : Set S ‚Ü™ Set V where
  toFun := fun I ‚Ü¶ Subtype.val '' I
  inj' := by intro _ _; simp only [Set.image_val_inj, imp_self]

omit [Fintype V] in
lemma embeddingOfSubsetSubtype_rw (S : Set V) (I : Set S) :
    embeddingOfSubsetSubtype S I = Subtype.val '' I := rfl

omit [Fintype V] in
lemma set_subtype_tofinset_card_iff {S : Set V} {I : Set S}
      : I.ncard = (Subtype.val '' I).ncard:=
    (Set.ncard_image_of_injective I Subtype.val_injective).symm

lemma IsIndependentInduce_map (S : Set V) : map (embeddingOfSubsetSubtype S) ‚Ñê(G.induce S)
    = (filter (¬∑ ‚äÜ S) ‚Ñê(G)) := by
  ext I
  simp_rw [mem_map, mem_filter, embeddingOfSubsetSubtype_rw, IsIndependentInduce]
  exact ‚ü® fun ‚ü®_, ‚ü®hI, hII'‚ü©‚ü© ‚Ü¶ (by rw [‚ÜêhII']; exact ‚ü®hI, Subtype.coe_image_subset _ _‚ü©),
          fun ‚ü®_, _‚ü© ‚Ü¶ ‚ü®{x | x.1 ‚àà I}, by simp_all‚ü©‚ü©

lemma IsIndependentInduce_implies {S : Set V} {I : Set S} (hI : I ‚àà ‚Ñê(induce S G)) :
    Subtype.val '' I ‚àà ‚Ñê(G) ‚àß Subtype.val '' I ‚äÜ S := by simp_all [IsIndependentInduce]

lemma induced_inedependent_set_count (S : Set V) [DecidablePred (¬∑ ‚àà S)] :
    #‚Ñê(G.induce S) = #(filter (¬∑ ‚äÜ S) ‚Ñê(G)) := by
  rw [‚ÜêIsIndependentInduce_map, Finset.card_map]
  congr
  exact Subsingleton.elim _ _

lemma mem_of_indepSetFinsetAll_card_le_indepNum {I : Set V} (hI : I ‚àà ‚Ñê(G))
    : I.ncard ‚â§ Œ±(G) := by
  rw [Set.ncard_eq_toFinset_card' I]
  exact IsIndepSet.card_le_indepNum (by rw [I_rw] at hI; rwa [Set.coe_toFinset])

variable (G) in
lemma exists_mem_indepSetFinsetAll_card_indepNum
    : ‚àÉ I ‚àà ‚Ñê(G), I.ncard = Œ±(G) := by
  have ‚ü®_, ‚ü®_, card_eq‚ü©‚ü© := G.exists_isNIndepSet_indepNum
  exact ‚ü®_, ‚ü®by rwa [I_rw], by rwa [Set.ncard_coe_finset]‚ü©‚ü©

/-The independent set version of `isClique_insert`.-/
lemma insert_mem_indepSetFinsetAll_iff {S : Set V}
    : (insert v S) ‚àà ‚Ñê(G) ‚Üî S ‚àà ‚Ñê(G) ‚àß ‚àÄ u ‚àà S, ¬¨G.Adj v u := by
  simp_rw [I_rw, ‚ÜêisClique_compl, isClique_insert, isClique_compl, compl_adj]
  exact ‚ü® fun ‚ü®hI, h‚ü© ‚Ü¶ ‚ü®hI, fun _ hu hAdj ‚Ü¶ (h _ hu (Adj.ne' hAdj).symm).2 hAdj‚ü©,
          fun ‚ü®hI, h‚ü© ‚Ü¶ ‚ü®hI, fun _ hu hvu ‚Ü¶ ‚ü®hvu, h _ hu‚ü©‚ü©‚ü©

lemma indepSet_augment {v : V} {I : Set V} (hI : I ‚àà ‚Ñê(G)) :
    I ‚äÜ (G.closedNeighborSet v)·∂ú ‚Üî v ‚àâ I ‚àß (insert v I) ‚àà ‚Ñê(G) := by
  rw [insert_mem_indepSetFinsetAll_iff]
  exact ‚ü®fun hI_sub ‚Ü¶ ‚ü®fun hIv ‚Ü¶ hI_sub hIv (Set.mem_insert _ _),
      ‚ü®hI, fun u hu hAdj ‚Ü¶ (hI_sub hu (Set.mem_insert_of_mem _ hAdj))‚ü©‚ü©,
        fun ‚ü®hvI, ‚ü®_, hAdj‚ü©‚ü© u huI huIn ‚Ü¶
       hAdj u huI (Adj_of_mem_closedNeighborSet_of_ne_v (by grind only) huIn)‚ü©

lemma indepSet_insert_bound (v : V) : Œ±(G) ‚â• Œ±(G.induce (G.closedNeighborSet v)·∂ú) + 1 := by
  have ‚ü®I, hI, hI_card‚ü© :=
    (induce (G := G) (G.closedNeighborSet v)·∂ú).exists_mem_indepSetFinsetAll_card_indepNum
  rw [‚ÜêhI_card, ge_iff_le]
  have this := IsIndependentInduce_implies (by convert hI)
  rw [indepSet_augment this.1] at this
  convert mem_of_indepSetFinsetAll_card_le_indepNum this.2.2
  rw [(Set.ncard_insert_of_notMem this.2.1), ‚Üêset_subtype_tofinset_card_iff]


lemma indepSet_card_recursion (v : V)
    : #‚Ñê(G) = #‚Ñê(G.induce {v}·∂ú) + #‚Ñê(G.induce (G.closedNeighborSet v)·∂ú) := by
  rw [add_comm]
  convert (Finset.filter_card_add_filter_neg_card_eq_card (p := (v ‚àà ¬∑))).symm
  ¬∑ convert induced_inedependent_set_count (G := G) (S := (G.closedNeighborSet v)·∂ú) using 1
    symm
    refine Finset.card_bij (i := fun S _ ‚Ü¶ insert v S) ?_ ?_ ?_
    ¬∑ intro S hS
      simp only [mem_filter, Set.mem_insert_iff, true_or, and_true]
      rw [mem_filter] at hS
      exact ((indepSet_augment hS.1).1 hS.2).2
    ¬∑ intro S‚ÇÅ hS‚ÇÅ S‚ÇÇ hS‚ÇÇ heq
      rw [mem_filter] at *
      refine Set.Subset.antisymm ?_ ?_ <;> rw [‚ÜêSet.insert_subset_insert_iff (a := v) ?_]
      ¬∑ exact Eq.subset heq
      ¬∑ exact fun hv ‚Ü¶ hS‚ÇÅ.2 hv self_mem_closedNeighborSet
      ¬∑ exact Eq.subset heq.symm
      ¬∑ exact fun hv ‚Ü¶ hS‚ÇÇ.2 hv self_mem_closedNeighborSet
    ¬∑ intro S hS
      use S \ {v}
      simp only [Set.insert_diff_singleton, Set.insert_eq_self, mem_filter,
        Set.diff_singleton_subset_iff, exists_prop]
      simp_rw [mem_filter] at hS
      refine ‚ü®‚ü®indepSetFinsetAll_subset hS.1 Set.diff_subset,?_‚ü©, hS.2‚ü©
      intro x hx
      refine Set.mem_insert_iff.mpr ?_
      rw [or_iff_not_imp_left]
      intro hxv hxNbr
      rw [I_rw] at hS
      apply hS.1 hx hS.2 hxv (Adj_of_mem_closedNeighborSet_of_ne_v (fun a ‚Ü¶ hxv a.symm) hxNbr).symm
  ¬∑ convert induced_inedependent_set_count (S := {v}·∂ú)
    simp
  ¬∑ exact inferInstance
  ¬∑ exact inferInstance


/-
  ## exists lemma
-/

/- `le` version of `exists_lt_of_lt_expect`-/
lemma exists_ge_of_le_expect {a : ‚Ñù} {g : V ‚Üí ‚Ñù} (h_nonempty : Nonempty V) (h : a ‚â§ ùîº i, g i)
  : ‚àÉ x, a ‚â§ g x := by
  have ‚ü®x, _, h_all‚ü© := exists_max_image (s := univ) (f := g) (univ_nonempty_iff.mpr h_nonempty)
  exact ‚ü®x, le_trans h (expect_le (univ_nonempty_iff.mpr h_nonempty) h_all)‚ü©


lemma Jensen_expect {Œ± : Type} {t : Finset Œ±} (ht : t.Nonempty) {s : Set ‚Ñù} {f : ‚Ñù ‚Üí ‚Ñù} (p : Œ± ‚Üí ‚Ñù)
    (hmem : ‚àÄ i ‚àà t, p i ‚àà s) (hf : ConvexOn ‚Ñù s f) : f (ùîº i ‚àà t, p i) ‚â§ ùîº i ‚àà t, f (p i) := by
  let Œº := (#t : ‚Ñù)
  obtain hŒº  : 0 < Œº := by simp_all only [Nat.cast_pos, card_pos, Œº]
  calc
    f (ùîº v ‚àà t, p v) = f ((‚àë v ‚àà t, p v) / Œº) := by
      congr
      exact expect_eq_sum_div_card t p
    _ = f (‚àë v ‚àà t, Œº‚Åª¬π ‚Ä¢ p v) := by
      simp_rw [Finset.sum_div, smul_eq_mul, mul_comm]
      congr
    _ ‚â§ ‚àë v ‚àà t, Œº‚Åª¬π ‚Ä¢ f (p v) := by
      apply ConvexOn.map_sum_le (w := fun _ ‚Ü¶ Œº‚Åª¬π) hf (by simp [Œº]) (by field_simp [Œº]) hmem
    _ = (‚àë v ‚àà t, f (p v)) / Œº := by
      simp_rw [Finset.sum_div, smul_eq_mul, mul_comm]
      congr
    _ = ùîº v ‚àà t, f (p v) := (expect_eq_sum_div_card t _).symm

lemma exp_expect_le_expect_exp (g : V ‚Üí ‚Ñù) (hV : Nonempty V)
    : Real.exp (ùîº v, g v) ‚â§ ùîº v, Real.exp (g v) :=
  Jensen_expect (univ_nonempty_iff.2 hV) _ (by simp) convexOn_exp


/-
  ## Shearer Step
-/

variable (G) in
noncomputable def extra (f f' : ‚Ñù ‚Üí ‚Ñù) (a : ‚Ñù) (b : ‚Ñù) :=
  if Nonempty V then a * (d(G) * f' d(G) - f d(G)) + b * (- 2 * f' d(G))
                else 0

lemma extra_nonempty {f f' : ‚Ñù ‚Üí ‚Ñù} {a : ‚Ñù} {b : ‚Ñù} (hV : Nonempty V) :
    extra G f f' a b = a * (d(G) * f' d(G) - f d(G)) + b * (- 2 * f' d(G)) :=
  if_pos hV

lemma extra_IsEmpty {f f' : ‚Ñù ‚Üí ‚Ñù} {a : ‚Ñù} {b : ‚Ñù} (hV : IsEmpty V) :
    extra G f f' a b = 0 := if_neg (not_nonempty_iff.2 hV)

lemma extra_rewrite_aux {f f' : ‚Ñù ‚Üí ‚Ñù} (hV : Nonempty V) : G.extra f f' (d(G) + 1) (d(G) ^ 2)
    = ((d(G)) - d(G)^2) * f' (d(G)) - ((d(G)) + 1) * f d(G) := by
  rw [extra_nonempty hV]
  ring

lemma extra_rewrite_aux' {f f' : ‚Ñù ‚Üí ‚Ñù} (hV : Nonempty V) : G.extra f f' 1 d(G)
    = - (d(G)) * f' (d(G)) - f (d(G)) := by
  rw [extra_nonempty hV]
  ring


variable (G) in
lemma extra_expect {f f' : ‚Ñù ‚Üí ‚Ñù} {g‚ÇÅ g‚ÇÇ : V ‚Üí ‚Ñù} :
    ùîº v, extra G f f' (g‚ÇÅ v) (g‚ÇÇ v) = extra G f f' (ùîº v, g‚ÇÅ v) (ùîº v, g‚ÇÇ v) := by
  unfold extra
  split_ifs
  ¬∑ rw [expect_add_distrib, ‚Üêexpect_mul, ‚Üêexpect_mul]
  ¬∑ exact expect_const_zero _

lemma extra_finset_zero {f f' : ‚Ñù ‚Üí ‚Ñù} (S : Set V) (h : d(G) = 0)
    : extra G f f' (#S.toFinset) 0 = -(#S.toFinset) * f 0 := by
  unfold extra
  split_ifs <;> simp_all

lemma extra_ineq {a b c : ‚Ñù} {f f' : ‚Ñù ‚Üí ‚Ñù} (hf' : ‚àÄ x, 0 < x ‚Üí f' x ‚â§ 0) (hab : b ‚â§ c)
    (hdG : 0 < d(G)) :
    extra G f f' a b ‚â§ extra G f f' a c := by
  unfold extra
  split_ifs
  ¬∑ gcongr
    linarith [hf' d(G) (Rat.cast_pos.mpr hdG)]
  ¬∑ exact le_refl _

noncomputable def convexIneq (f f' : ‚Ñù ‚Üí ‚Ñù) :=
    ‚àÄ x y, 0 ‚â§ x ‚Üí 0 < y ‚Üí f x ‚â• f y + f' y * (x - y)

lemma shearer_convex_step {V‚ÇÅ V‚ÇÇ : Type} [Fintype V‚ÇÅ] [Fintype V‚ÇÇ]
    {H‚ÇÅ : SimpleGraph V‚ÇÅ} {H‚ÇÇ : SimpleGraph V‚ÇÇ} (f f' : ‚Ñù ‚Üí ‚Ñù) (hf : convexIneq f f')
    (hdH‚ÇÅ : 0 < d(H‚ÇÅ)) : #V(H‚ÇÇ) * f d(H‚ÇÇ) ‚â•
    #V(H‚ÇÅ) * f d(H‚ÇÅ) + extra H‚ÇÅ f f' (#V(H‚ÇÅ) - #V(H‚ÇÇ)) (#E(H‚ÇÅ) - #E(H‚ÇÇ))
  := by
  have h_ineq := hf d(H‚ÇÇ) d(H‚ÇÅ) (Rat.cast_nonneg.2 averageDegree_nonneg) (Rat.cast_pos.2 hdH‚ÇÅ)
  have cast_rw (a : ‚Ñï) : (a : ‚Ñù) = ((a : ‚Ñö) : ‚Ñù) := rfl
  refine le_trans ?_ (mul_le_mul_of_nonneg_left h_ineq (Nat.cast_nonneg _))
  rw [extra_nonempty (vertexType_Nonempty_from_averageDegree_pos hdH‚ÇÅ),
      ‚Üêmul_assoc, mul_comm (b := -2), neg_mul_comm, neg_sub,
      mul_sub (a := 2), ‚ÜêNat.cast_ofNat, ‚ÜêNat.cast_mul, ‚ÜêNat.cast_mul, cast_rw (2 * #E(H‚ÇÇ)),
      Nat.cast_mul,Nat.cast_ofNat, ‚ÜêaverageDegree_eq_twice_card_edges_div_card,
      cast_rw (2 * #E(H‚ÇÅ)), Nat.cast_mul,Nat.cast_ofNat,
      ‚ÜêaverageDegree_eq_twice_card_edges_div_card, Rat.cast_mul, Rat.cast_natCast,
      Rat.cast_mul, Rat.cast_natCast, ‚Üêsub_nonneg]
  convert le_refl _
  ring

lemma convex_step_induce (S : Set V) {f f' : ‚Ñù ‚Üí ‚Ñù} (hf : convexIneq f f')
  : #V(G.induce S·∂ú) * f d(G.induce S·∂ú) ‚â• #V(G) * f d(G) +
    extra G f f' #S.toFinset #(G.EdgeIncidenceFinset S)  := by
    by_cases hd : d(G) = 0
    ¬∑ have this : d(induce S·∂ú G) = 0 := by
        convert induceAveragedegree_zero_from_averageDegree_zero hd _
      rw [hd, this, Rat.cast_zero,
      EdgeIncidenceFinset_card_zero_from_averageDegree_zero hd, Nat.cast_zero,
      extra_finset_zero _ hd, neg_mul, ge_iff_le, add_neg_le_iff_le_add, ‚Üêadd_mul,
      ‚ÜêNat.cast_add, add_comm, induce_vertex_card, (vertex_card_induce_sum S)]
    ¬∑ convert shearer_convex_step (H‚ÇÅ := G) (H‚ÇÇ := G.induce S·∂ú) f f' hf
        (averageDegree_pos_from_nonzero hd) <;>
      rw [eq_sub_iff_add_eq, ‚ÜêNat.cast_add, Nat.cast_inj]
      ¬∑ rw [induce_vertex_card]
        exact (vertex_card_induce_sum S).symm
      ¬∑ exact (edge_card_induce_sum S).symm

lemma convex_step_expect {F : V ‚Üí Set V} {f f' : ‚Ñù ‚Üí ‚Ñù} (hf : convexIneq f f')
  : ùîº v, #V(G.induce (F v)·∂ú) * f d(G.induce (F v)·∂ú) ‚â• #V(G) * f d(G) +
    extra G f f' (ùîº v, #(F v).toFinset) (ùîº v, #(G.EdgeIncidenceFinset (F v))) := by
  rw [ge_iff_le]
  convert expect_le_expect
    (f := fun v ‚Ü¶ #V(G) * f d(G) + extra G f f' #(F v).toFinset #(G.EdgeIncidenceFinset (F v)))
    (fun v hv ‚Ü¶ convex_step_induce _ hf) using 1
  rw [expect_add_distrib, extra_expect]
  congr 1
  by_cases hV : #V(G) = 0
  ¬∑ simp [hV]
  ¬∑ exact (expect_const (card_ne_zero.mp hV) _).symm

lemma convex_step_expect_closedNeighbor {f f' : ‚Ñù ‚Üí ‚Ñù} (hf : convexIneq f f')
    (hT : G.CliqueFree 3) (hf' : ‚àÄ (x : ‚Ñù), 0 < x ‚Üí f' x ‚â§ 0)
    : ùîº v, #V(G.induce (G.closedNeighborSet v)·∂ú) * f d(G.induce (G.closedNeighborSet v)·∂ú)
    ‚â• #V(G) * f d(G) + extra G f f' (d(G) + 1) (d(G) ^ 2) := by
  by_cases hV : Nonempty V
  ¬∑ refine le_trans ?_ (convex_step_expect (F := fun v ‚Ü¶ G.closedNeighborSet v) hf)
    gcongr
    rw [expect_closedNeighbor_card_real hV, incidence_closedNeighbor_expectation_real hT,
      ‚ÜêRat.cast_pow]
    by_cases hdG : d(G) = 0
    ¬∑ simp [hdG, degree_zero_of_avg_zero]
    ¬∑ exact extra_ineq hf'  (Rat.cast_le.2 averageDegree_square_bound)
                            (averageDegree_pos_from_nonzero hdG)
  ¬∑ simp_all [extra_IsEmpty, card_vertices_eq_zero_from_empty]

theorem Shearer_bound (hT : G.CliqueFree 3) {f f' : ‚Ñù ‚Üí ‚Ñù} (hf : convexIneq f f')
    (hf' : ‚àÄ (x : ‚Ñù), 0 < x ‚Üí f' x ‚â§ 0)
    (h_extra : ‚àÄ {V' : Type} [Fintype V'] {G' : SimpleGraph V'},
      0 ‚â§ G'.extra f f' (d(G') + 1) (d(G') ^ 2) + 1)
    : Œ±(G) ‚â• #V(G) * f d(G) := by
  suffices h : ‚àÄ n, ‚àÄ {V' : Type} [Fintype V'] {G' : SimpleGraph V'} (hn : n = #V(G'))
    (hT : G'.CliqueFree 3), Œ±(G') ‚â• n * (f d(G')) from (h _ rfl hT)
  intro n
  induction' n using Nat.strong_induction_on with n hn
  intro V _ G hcard hT
  by_cases hV : Nonempty V
  ¬∑ rw [‚Üêexpect_const (univ_nonempty_iff.mpr hV) (Œ±(G) : ‚Ñù)]
    calc
      ùîº v, (Œ±(G) : ‚Ñù)   ‚â• ùîº v, ((Œ±(G.induce (G.closedNeighborSet v)·∂ú) + 1 : ‚Ñï) : ‚Ñù) :=
        expect_le_expect (fun _ _ ‚Ü¶ (Nat.cast_le.2 (indepSet_insert_bound _)))
      _                 = ùîº v, (Œ±(G.induce (G.closedNeighborSet v)·∂ú) + 1 : ‚Ñù) := by simp
      _                 = (ùîº v, (Œ±(G.induce (G.closedNeighborSet v)·∂ú) : ‚Ñù)) + 1 := by
        rw [expect_add_distrib, expect_const (univ_nonempty_iff.mpr hV) _]
      _                 ‚â• (ùîº v, #V(G.induce (G.closedNeighborSet v)·∂ú) *
                          f d(G.induce (G.closedNeighborSet v)·∂ú)) + 1 := by
        gcongr;
        apply hn
        ¬∑ rw [hcard]
          exact induce_vertex_card_compl_lt nonempty_closedNeighborSet
        ¬∑ rfl
        ¬∑ exact CliqueFree.comap (Embedding.induce _) hT
      _                 ‚â• #V(G) * f d(G) + extra G f f' (d(G) + 1) (d(G) ^ 2) + 1 := by
        gcongr;
        exact convex_step_expect_closedNeighbor hf hT hf'
      _                 ‚â• #V(G) * f d(G) + 0  := by
        rw [add_assoc]
        gcongr
        exact h_extra
      _                 = #V(G) * f d(G)      := add_zero _
    rw [hcard]
  ¬∑ rw [card_vertices_eq_zero_from_empty (not_nonempty_iff.mp hV)] at hcard
    simp [hcard]


/-
  ## The result for independent set count
-/

lemma convex_step_expect_vertex_complement {f f' : ‚Ñù ‚Üí ‚Ñù} (hf : convexIneq f f')
    : ùîº v, #V(G.induce {v}·∂ú) * f d(G.induce {v}·∂ú)
    ‚â• #V(G) * f d(G) + extra G f f' 1 d(G) := by
  by_cases hV : Nonempty V
  ¬∑ convert (convex_step_expect (F := fun v ‚Ü¶ {v}) hf)
    ¬∑ simp
    ¬∑ simp [edge_incidence_singelton_card, averageDegree_real_cast]
  ¬∑ simp_all [card_vertices_eq_zero_from_empty, extra_IsEmpty]

theorem independent_set_count_bound (hT : G.CliqueFree 3) {f f' : ‚Ñù ‚Üí ‚Ñù}
    (hf : convexIneq f f')
    (hf' : ‚àÄ (x : ‚Ñù), 0 < x ‚Üí f' x ‚â§ 0)
    (h_extra : ‚àÄ {V' : Type} [Fintype V'] {G' : SimpleGraph V'},
      1 ‚â§
        Real.exp (G'.extra f f' 1 d(G')) +
        Real.exp (G'.extra f f' (d(G') + 1) (d(G') ^ 2)))
    : #‚Ñê(G) ‚â• Real.exp (#V(G) * f d(G)) := by
  suffices h : ‚àÄ n, ‚àÄ {V' : Type} [Fintype V'] {G' : SimpleGraph V'} (hn : n = #V(G'))
    (hT : G'.CliqueFree 3), #‚Ñê(G') ‚â• Real.exp (#V(G') * f d(G')) from (h _ rfl hT)
  intro n
  induction' n using Nat.strong_induction_on with n hn
  intro V _ G hcard hT
  by_cases hV : Nonempty V
  ¬∑ rw [‚Üêexpect_const (univ_nonempty_iff.mpr hV) (#‚Ñê(G) : ‚Ñù)]
    calc
      ùîº v, (#‚Ñê(G) : ‚Ñù)
            = ùîº v, (#‚Ñê(G.induce {v}·∂ú) + #‚Ñê(G.induce (G.closedNeighborSet v)·∂ú) : ‚Ñù ) := by
        apply expect_congr rfl
        exact_mod_cast fun _ _ ‚Ü¶ indepSet_card_recursion _
      _   =   ùîº v, (#‚Ñê(G.induce {v}·∂ú) : ‚Ñù)
            + ùîº v, (#‚Ñê(G.induce (G.closedNeighborSet v)·∂ú) : ‚Ñù )  := expect_add_distrib _ _ _
      _   ‚â•   ùîº v, Real.exp (#V(G.induce {v}·∂ú) * f d(G.induce {v}·∂ú))
            + ùîº v, Real.exp (#V(G.induce (G.closedNeighborSet v)·∂ú)
                              * f d(G.induce (G.closedNeighborSet v)·∂ú)) := by
        gcongr <;> rename_i v hv
        ¬∑ apply hn (#V(G.induce {v}·∂ú))
          ¬∑ rw [hcard]
            refine induce_vertex_card_compl_lt ‚ü®v, rfl‚ü©
          ¬∑ rfl
          ¬∑ exact CliqueFree.comap (Embedding.induce _) hT
        ¬∑ apply hn (#V(G.induce (G.closedNeighborSet v)·∂ú))
          ¬∑ rw [hcard]
            refine induce_vertex_card_compl_lt nonempty_closedNeighborSet
          ¬∑ rfl
          ¬∑ exact CliqueFree.comap (Embedding.induce _) hT
      _   ‚â•   Real.exp (ùîº v, #V(G.induce {v}·∂ú) * f d(G.induce {v}·∂ú))
            + Real.exp (ùîº v, #V(G.induce (G.closedNeighborSet v)·∂ú)
                              * f d(G.induce (G.closedNeighborSet v)·∂ú)) := by
        gcongr <;> exact exp_expect_le_expect_exp _ hV
      _   ‚â•   Real.exp (#V(G) * f d(G) + extra G f f' 1 d(G))
            + Real.exp (#V(G) * f d(G) + extra G f f' (d(G) + 1) (d(G) ^ 2)) := by
        gcongr
        ¬∑ exact convex_step_expect_vertex_complement hf
        ¬∑ exact convex_step_expect_closedNeighbor hf hT hf'
      _   = Real.exp (#V(G) * f d(G)) *
            (Real.exp (extra G f f' 1 d(G)) + Real.exp (extra G f f' (d(G) + 1) (d(G) ^ 2))) := by
        rw [Real.exp_add, Real.exp_add, mul_add]
      _                 ‚â• Real.exp (#V(G) * f d(G)) := by
        nth_rewrite 2 [‚Üêmul_one (a := Real.exp (‚Üë(#V(G)) * f ‚Üëd(G)))]
        gcongr
        exact h_extra
  ¬∑ simp [card_vertices_eq_zero_from_empty (not_nonempty_iff.mp hV), indepSetFinsetAll_nonempty]

end SimpleGraph
